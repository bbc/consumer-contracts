import { createBuilder } from "@bbc/http-transport";
import createDebug from "debug";
import Joi, { ValidationErrorItem, ValidationOptions } from "joi";
import _ from "lodash";
import { ValidationResult } from "./formatter";
const { version } = require('./../package.json');

const debug = createDebug("consumer-contracts");

const requiredOptions = ["name", "consumer", "request", "response"];

function timeout(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const joiOptions = {
  allowUnknown: true,
  presence: "required",
};

function validateOptions(options: ContractOptions) {
  options = options || {};
  requiredOptions.forEach((key) => {
    if (!options.hasOwnProperty(key)) {
      throw new Error(`Invalid contract: Missing required property [${key}]`);
    }
  });
}

export function assertIsAsyncBeforeAfter(fn: BeforeAfterFn): asserts fn is () => Promise<void> {
  if (fn.length !== 0) {
    throw new Error('Asynchronous before functions do not accept callbacks!')
  }
}


export type TransformedResponse = {
  url: string;
  status: number;
  statusCode: number;
  statusText: string;
  headers: Object;
  body: any;
};

function createError(detail: ValidationErrorItem, path: (string | number)[], res: TransformedResponse) {
  const err = new Error(`Contract failed: ${detail.message}`);
  (err as any).detail = `at res.${path} got [${_.get(res, path)}]`;

  return err;
}

type ContractRequestHeaders = Object;

export type ContractRequest = {
  timeout?: number;
  headers?: ContractRequestHeaders;
  query?: Object;
  method?: string;
  json?: boolean;
  url: string;
  body?: any;
}

export type ContractResponse = {
  url: string;
  statusCode: number;
  status: number;
  statusText: string;
  headers: ContractRequestHeaders;
  body?: any;
}

/**
 * Use with old style clients like \@ibl/request.
 * @deprecated See ContractCustomAsyncClient.
 */
export type ContractCustomClient = {
  defaults: (cr: ContractRequest) => ({
    get: (url: string, request: ContractRequest, callback: (err: any, resp: ContractResponse) => void) => void,
    post: (url: string, request: ContractRequest, callback: (err: any, resp: ContractResponse) => void) => void,
    patch: (url: string, request: ContractRequest, callback: (err: any, resp: ContractResponse) => void) => void,
    put: (url: string, request: ContractRequest, callback: (err: any, resp: ContractResponse) => void) => void,
    delete: (url: string, request: ContractRequest, callback: (err: any, resp: ContractResponse) => void) => void,
  });
}

/**
 * This type matches @ibl/rest-client and http-transport. To make use of a custom asyncClient you will have to map your asyncClient to a format similar to the below.
 * See fetch-client.ts for an example.
 */
export type ContractCustomAsyncClient = {
  get: (url: string, request: ContractRequest) => Promise<ContractResponse>,
  post: (url: string, body: any, request: ContractRequest) => Promise<ContractResponse>,
  patch: (url: string, body: any, request: ContractRequest) => Promise<ContractResponse>,
  put: (url: string, body: any, request: ContractRequest) => Promise<ContractResponse>,
  delete: (url: string, request: ContractRequest) => Promise<ContractResponse>,
}

type BeforeAfterFn = (() => Promise<unknown>) | ((callback: (val: any) => void) => void);

export type ContractOptions = {
  request: ContractRequest;
  response: Joi.PartialSchemaMap<any> | undefined;
  name: string;
  consumer: string;
  before?: BeforeAfterFn;
  after?: BeforeAfterFn;
  retries?: number | {
    maxRetries: number;
    handler: (
      error: {
        message: string;
        detail: string;
        statusCode: number;
        response?: any;
        request?: any;
      },
      request: ContractRequest,
      retryCount: number
    ) => boolean | number;
  };
  retryDelay?: number;
  joiOptions?: ValidationOptions;
  /**
   * Supports old style callback clients such as those generated by the now retired \@ibl/request library.
   * @deprecated you should upgrade to a modern async client such as \@ibl/rest-client or \@bbc/http-transport or pass no client at all to default to \@bbc/http-transport.
   */
  client?: ContractCustomClient;
  /**
   * Supports modern async clients such as \@ibl/rest-client or \@bbc/http-transport.
   */
  asyncClient?: ContractCustomAsyncClient;
}

/**
 * Create a contract with a third party API. Allows for client, request and validation configuration.
 */
export class Contract {
  name: string;
  consumer: string;
  before?: ContractOptions['before'];
  after?: ContractOptions['after'];
  retries: ContractOptions['retries'];
  retryDelay: number;
  _request: ContractRequest;
  _response: Joi.PartialSchemaMap<any> | undefined;
  _requestOptions: ContractRequest;
  _defaultRequestOptions: Partial<ContractRequest>;
  _client: (request: ContractRequest) => Promise<ContractResponse>;
  joiOptions: ValidationOptions;

  constructor(options: ContractOptions) {
    validateOptions(options);
    this.name = options.name;
    this.consumer = options.consumer;
    this.before = options.before;
    this.after = options.after;
    this.retries = options.retries || 0;
    this.retryDelay = options.retryDelay || 0;

    this._request = options.request;
    this._defaultRequestOptions = {
      json: true,
      headers: {
        "user-agent": "consumer-contracts/" + version,
      },
    };
    this._requestOptions = _.merge({}, this._defaultRequestOptions, this._request);
    this._response = options.response;

    if (options.client) {
      const defaultedClient = options.client.defaults(this._requestOptions);
      this._client = async function (request: ContractRequest) {
        return new Promise<ContractResponse>((resolve, reject) => {
          return (<any>defaultedClient)[(request.method || "get").toLowerCase()](
            request.url,
            request,
            (err: any, resp: ContractResponse) => {
              if (err) reject(new Error(`Request failed: ${err.message}`));
              resolve(resp);
            }
          );
        });
      }
    }
    else if (options.asyncClient) {
      this._client = async (request: ContractRequest) => {
        const requestMerged = _.merge({}, this._requestOptions, request);
        if (options.asyncClient) {
          if (requestMerged.method && (requestMerged.method.toLowerCase() === 'post' || requestMerged.method.toLowerCase() === 'patch' || requestMerged.method.toLowerCase() === 'put')) return (<any>options.asyncClient)[(requestMerged.method).toLowerCase()](requestMerged.url, requestMerged.body, requestMerged);
          else return (<any>options.asyncClient)[(requestMerged.method || "get").toLowerCase()](requestMerged.url, requestMerged);
        }
      }
    }
    else {
      // build http transport based client
      const builder = createBuilder();

      const httpTransportClient = builder.createClient()
        .timeout(this._requestOptions.timeout || 0)
        .headers(this._requestOptions.headers || {})
        .query(this._requestOptions.query || {})
        .redirect('manual');

      this._client = async function (request: ContractRequest) {
        return (<any>httpTransportClient)[(this._request.method || "get").toLowerCase()](request.url, request.body).asResponse();
      }
    }

    this.joiOptions = _.merge({}, joiOptions, options.joiOptions || {});
  }

  /**
   * Validate your contract by fetching from the supplied endpoint and options and validating using Joi schemas.
   * @param {*} callback a callback that contains errors if there were any. Expected to be called with no arguments if the validation succeeded.
   * @returns void
   */
  async validate(callback: (err: any, result: ValidationResult | undefined) => void) {
    const schema = Joi.object().keys(this._response);

    let schemaValidationResult;
    let validationError: any = undefined;
    let validationResult: ValidationResult | undefined = undefined;

    if (this.before) {
      if (this.before.constructor.name === 'AsyncFunction') {
        // Promise-based before
        assertIsAsyncBeforeAfter(this.before);

        try {
          await this.before();
        } catch (error) {
          callback(error, undefined);
          return;
        }
      } else {
        // Old-style callback before
        let beforeHasErrored = false;
        this.before((val) => {
          callback(val, undefined);
          if (val instanceof Error) beforeHasErrored = true;
        });
        if (beforeHasErrored) return;
      }
    }

    try {
      const maxRetries = typeof this.retries === 'number' 
        ? this.retries 
        : (this.retries?.maxRetries ?? 0);
      let retryCount = 0;
      let lastResponse: TransformedResponse | undefined;

      while (retryCount <= maxRetries) {
        const clientResponse = await this._client(this._request);

        lastResponse = {
          url: clientResponse.url,
          status: clientResponse.statusCode || clientResponse.status,
          statusCode: clientResponse.statusCode || clientResponse.status,
          statusText: clientResponse.statusText,
          headers: clientResponse.headers,
          body: clientResponse.body,
        };

        debug(`${lastResponse.url} ${lastResponse.status}`);

        schemaValidationResult = schema.validate(lastResponse, this.joiOptions);

        if (!schemaValidationResult.error) {
          validationResult = schemaValidationResult;
          break;
        }

        if (retryCount < maxRetries) {
          if (typeof this.retries === 'object') {
            const validationError = {
              message: schemaValidationResult.error.message,
              detail: schemaValidationResult.error.details[0].message,
              statusCode: lastResponse.statusCode,
              response: lastResponse,
              request: this._request
            };

            const shouldRetry = this.retries.handler(
              validationError,
              this._request,
              retryCount
            );

            if (!shouldRetry) {
              break;
            }

            if (typeof shouldRetry === 'number' && shouldRetry > 0) {
              await timeout(shouldRetry);
            }
          } else if (this.retryDelay > 0) {
            await timeout(this.retryDelay);
          }
          retryCount++;
        } else {
          break;
        }
      }

      if (schemaValidationResult?.error && lastResponse) {
        const detail = schemaValidationResult.error.details[0];
        const path = detail.path;
        validationError = createError(detail, path, lastResponse);
      }
    } catch (error) {
      validationError = error;
    }

    if (this.after) {
      try {
        if (this.after.constructor.name === 'AsyncFunction') {
          assertIsAsyncBeforeAfter(this.after);
          await this.after();
        } else {
          await new Promise<void>((resolve, reject) => {
            this.after!((val) => {
              if (val) reject(val);
              else resolve();
            });
          });
        }
      } catch (afterError) {
        callback(afterError, undefined);
        return;
      }
    }

    callback(validationError, validationResult);
  }
}